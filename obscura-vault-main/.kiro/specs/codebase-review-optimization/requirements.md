# Requirements Document

## Introduction

This document specifies requirements for a comprehensive review, analysis, optimization, and testing effort for the Obscura post-quantum private intent settlement system with ShadowWire integration. The system combines WOTS+ (Winternitz One-Time Signatures) for quantum resistance, SIP (Shielded Intent Protocol) for privacy, ShadowWire for Bulletproof-based private transfers on Solana, and minimal on-chain settlement contracts.

## Glossary

- **WOTS_Scheme**: The Winternitz One-Time Signature Plus implementation providing post-quantum secure signatures
- **Merkle_Tree**: Binary hash tree for efficient batch commitment verification
- **SIP_Settlement**: The EVM smart contract handling commitment verification and replay protection
- **SIP_Vault**: The EVM smart contract handling asset custody and withdrawal execution
- **Crypto_Package**: The TypeScript package containing WOTS+ and Merkle tree primitives
- **Backend_Package**: The TypeScript package containing off-chain services and API
- **ShadowWire_Client**: The TypeScript SDK for private transfers on Solana using Bulletproofs
- **Bulletproof**: Zero-knowledge range proof system used by ShadowWire to hide transaction amounts
- **Property_Test**: A test that verifies a universal property holds across many generated inputs

## Requirements

### Requirement 1: WOTS+ Cryptographic Correctness

**User Story:** As a security auditor, I want to verify that the WOTS+ implementation is cryptographically correct, so that the system provides genuine post-quantum security.

#### Acceptance Criteria

1. FOR ALL valid private keys, THE WOTS_Scheme SHALL produce a public key that can verify signatures created with that private key
2. FOR ALL message hashes and valid key pairs, THE WOTS_Scheme SHALL produce signatures that verify correctly
3. FOR ALL corrupted signatures, THE WOTS_Scheme SHALL reject verification
4. FOR ALL different messages signed with the same key, THE WOTS_Scheme SHALL produce different signatures
5. WHEN serializing and deserializing public keys, THE WOTS_Scheme SHALL preserve equality
6. WHEN serializing and deserializing signatures, THE WOTS_Scheme SHALL preserve verification validity

### Requirement 2: Merkle Tree Correctness

**User Story:** As a developer, I want to verify that the Merkle tree implementation is correct, so that batch commitments can be reliably verified.

#### Acceptance Criteria

1. FOR ALL sets of leaves, THE Merkle_Tree SHALL produce a deterministic root hash
2. FOR ALL valid leaf indices, THE Merkle_Tree SHALL generate proofs that verify against the root
3. FOR ALL invalid leaves, THE Merkle_Tree SHALL reject proof verification
4. FOR ALL proofs with corrupted siblings, THE Merkle_Tree SHALL reject verification
5. WHEN computing root from proof, THE Merkle_Tree SHALL produce the same root as the original tree

### Requirement 3: TypeScript-Solidity Merkle Compatibility

**User Story:** As a system integrator, I want the TypeScript and Solidity Merkle implementations to be compatible, so that proofs generated off-chain verify on-chain.

#### Acceptance Criteria

1. FOR ALL Merkle proofs generated by the TypeScript implementation, THE MerkleVerifier Solidity library SHALL verify them correctly
2. FOR ALL leaf hashes, THE TypeScript and Solidity implementations SHALL compute identical parent hashes
3. WHEN using domain separation prefix 0x01, BOTH implementations SHALL produce identical results

### Requirement 4: Settlement Contract Security

**User Story:** As a security auditor, I want to verify that the settlement contract prevents replay attacks and unauthorized access, so that user funds are protected.

#### Acceptance Criteria

1. FOR ALL settled commitments, THE SIP_Settlement SHALL reject subsequent settlement attempts with the same commitment
2. FOR ALL invalid Merkle proofs, THE SIP_Settlement SHALL reject settlement
3. WHEN a non-executor calls updateRoot, THE SIP_Settlement SHALL revert with Unauthorized
4. FOR ALL batch settlements, THE SIP_Settlement SHALL enforce the maximum batch size limit
5. WHEN settling against a historical batch, THE SIP_Settlement SHALL verify against the correct root

### Requirement 5: Vault Contract Security

**User Story:** As a security auditor, I want to verify that the vault contract correctly manages deposits and withdrawals, so that user assets are secure.

#### Acceptance Criteria

1. FOR ALL deposits, THE SIP_Vault SHALL correctly track token balances
2. FOR ALL withdrawal attempts exceeding balance, THE SIP_Vault SHALL revert with InsufficientBalance
3. FOR ALL used commitments, THE SIP_Vault SHALL reject subsequent withdrawal attempts
4. WHEN paused, THE SIP_Vault SHALL reject all deposits and withdrawals
5. WHEN receiving direct ETH transfers, THE SIP_Vault SHALL revert to prevent untracked deposits

### Requirement 6: Gas Optimization Verification

**User Story:** As a developer, I want to verify that gas optimizations are effective, so that the system remains economically viable.

#### Acceptance Criteria

1. WHEN settling a single commitment, THE SIP_Settlement SHALL use less than 120,000 gas
2. WHEN settling a batch of 10 commitments, THE SIP_Settlement SHALL use less than 200,000 gas total
3. WHEN updating the root, THE SIP_Settlement SHALL use less than 90,000 gas

### Requirement 7: Key Pool Management

**User Story:** As a user, I want the key pool to correctly manage one-time key usage, so that keys are never reused (which would compromise security).

#### Acceptance Criteria

1. FOR ALL derived keys from the same seed and index, THE WOTS_Scheme SHALL produce identical keys
2. FOR ALL different indices, THE WOTS_Scheme SHALL produce different keys
3. WHEN registering a key pool, THE Auth_Service SHALL track the total key count and owner

### Requirement 8: Test Coverage Enhancement

**User Story:** As a quality engineer, I want comprehensive test coverage including property-based tests, so that edge cases and invariants are verified.

#### Acceptance Criteria

1. THE Crypto_Package SHALL have property-based tests for WOTS+ sign/verify round-trip
2. THE Crypto_Package SHALL have property-based tests for Merkle proof generation/verification
3. THE Backend_Package SHALL have integration tests for the auth service
4. THE EVM contracts SHALL have fuzz tests for settlement operations

### Requirement 9: ShadowWire SDK Integration

**User Story:** As a developer, I want to integrate ShadowWire for private Solana transfers, so that users can make privacy-preserving payments with hidden amounts.

#### Acceptance Criteria

1. WHEN initializing the ShadowWire_Client, THE system SHALL connect to the ShadowWire API successfully
2. WHEN checking balance, THE ShadowWire_Client SHALL return available balance and pool address
3. WHEN making an internal transfer, THE ShadowWire_Client SHALL hide the transaction amount using Bulletproofs
4. WHEN making an external transfer, THE ShadowWire_Client SHALL keep sender anonymous while showing amount
5. WHEN wallet signature is missing, THE ShadowWire_Client SHALL reject the transfer request

### Requirement 10: ShadowWire Transfer Correctness

**User Story:** As a user, I want private transfers to work correctly, so that my funds are safe and amounts are properly hidden.

#### Acceptance Criteria

1. FOR ALL valid internal transfers, THE ShadowWire_Client SHALL successfully hide the amount on-chain
2. FOR ALL transfers with insufficient balance, THE ShadowWire_Client SHALL throw InsufficientBalanceError
3. FOR ALL transfers to non-ShadowWire users via internal type, THE ShadowWire_Client SHALL throw RecipientNotFoundError
4. WHEN transferring to self, THE ShadowWire_Client SHALL reject the transfer for security
5. FOR ALL supported tokens (SOL, USDC, RADR, etc.), THE ShadowWire_Client SHALL correctly convert amounts using token decimals

### Requirement 11: ShadowWire Proof Generation

**User Story:** As a privacy-conscious user, I want the option to generate proofs client-side, so that the backend never sees my transaction amounts.

#### Acceptance Criteria

1. WHEN WASM is supported, THE ShadowWire_Client SHALL allow client-side proof generation
2. WHEN generating a range proof, THE ShadowWire_Client SHALL produce a valid Bulletproof
3. WHEN WASM is not supported, THE ShadowWire_Client SHALL fall back to backend proof generation
4. FOR ALL client-generated proofs, THE ShadowWire_Client SHALL accept them in transferWithClientProofs

### Requirement 12: ShadowWire Error Handling

**User Story:** As a developer, I want clear error handling, so that I can provide good user feedback when transfers fail.

#### Acceptance Criteria

1. WHEN recipient is not found, THE ShadowWire_Client SHALL throw RecipientNotFoundError with clear message
2. WHEN balance is insufficient, THE ShadowWire_Client SHALL throw InsufficientBalanceError with available balance
3. WHEN wallet signature is invalid, THE ShadowWire_Client SHALL throw authentication error
4. FOR ALL API errors, THE ShadowWire_Client SHALL provide typed error objects with actionable information
